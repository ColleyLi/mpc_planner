import os
import datetime

from util.code_generation import tabs, open_function, close_function, add_zero_below_10
from util.files import generated_src_file, generated_include_file, solver_name, get_package_path, planner_path, get_current_package

from util.logging import print_success, print_path


def generate_module_header(modules):
    path = f"{get_package_path('mpc-planner-modules')}/include/mpc-planner-modules/modules.h"
    print_path("Module Header", path, end="", tab=True)

    module_header = open(path, "w")

    module_header.write("#ifndef __MPC_PLANNER_GENERATED_MODULES_H__\n")
    module_header.write("#define __MPC_PLANNER_GENERATED_MODULES_H__\n\n")
    for module in modules.modules:
        module_header.write(f"#include <mpc-planner-modules/{module.import_name}>\n")
        for source in module.sources:
            module_header.write(f"#include <mpc-planner-modules/{source}>\n")

    module_header.write("\n")

    module_header.write("namespace MPCPlanner\n{\n")
    module_header.write("\tclass Solver;\n")
    module_header.write(
        "\tinline void initializeModules(std::vector<std::shared_ptr<ControllerModule>> &modules, std::shared_ptr<Solver> solver)\n\t{\n"
    )

    for module in modules.modules:
        module_header.write("\t\tmodules.emplace_back(nullptr);\n")
        module_header.write("\t\tmodules.back() = std::make_shared<" + module.module_name + ">(solver);\n")
    module_header.write("\n\t}\n")
    module_header.write("}")

    module_header.write("\n#endif")

    module_header.close()
    print_success(" -> generated")


def generate_module_definitions(modules):
    path = f"{get_package_path('mpc-planner-modules')}/include/mpc-planner-modules/definitions.h"
    print_path("Definition Header", path, end="", tab=True)

    definitions_header = open(path, "w")

    definitions_header.write("#ifndef __MPC_PLANNER_GENERATED_DEFINITIONS_H__\n")
    definitions_header.write("#define __MPC_PLANNER_GENERATED_DEFINITIONS_H__\n\n")

    for module in modules.modules:
        module.add_definitions(definitions_header)
    definitions_header.write("\n")

    definitions_header.write("\n#endif")

    definitions_header.close()
    print_success(" -> generated")


def generate_module_cmake(modules):
    path = f"{get_package_path('mpc-planner-modules')}/modules.cmake"
    print_path("Module CMake", path, end="", tab=True)
    module_cmake = open(path, "w")

    module_cmake.write("set(MODULE_DEPENDENCIES\n")
    dependencies = []
    for module in modules.modules:
        for dependency in module.dependencies:
            if dependency not in dependencies:
                dependencies.append(dependency)
                module_cmake.write(f"\t{dependency}\n")
    module_cmake.write(")\n\n")

    module_cmake.write("set(MODULE_SOURCES\n")
    for module in modules.modules:
        module_cmake.write(f"\tsrc/{module.import_name.split('.')[0]}.cpp\n")
        for source in module.sources:
            module_cmake.write(f"\tsrc/{source.split('.')[0]}.cpp\n")

    module_cmake.write(")\n")
    module_cmake.close()
    print_success(" -> generated")


def generate_module_packagexml(modules):
    path = f"{get_package_path('mpc-planner-modules')}/package.xml"
    print_path("Package.xml", path, end="", tab=True)

    line_start = "<!-- START SOLVER DEPENDENT -->"
    line_end = "<!-- END SOLVER DEPENDENT -->"

    # Create a list to store lines to append
    new_lines = []
    found_start = False
    found_end = False

    # Step 1: Open the file in read mode
    with open(path, "r") as file:
        for line in file:
            # Step 3: Check if the current line matches the target line
            if line_start in line:
                new_lines.append(line)
                found_start = True  # Set the flag to True
                for module in modules.modules:
                    for dep in module.dependencies:
                        new_lines.append("\t<depend>" + dep + "</depend>\n")

            if line_end in line:
                found_end = True

            if found_start and not found_end:
                continue

            # If the target line hasn't been found, add it to the list
            new_lines.append(line)

    # If nothing was out of place with the tags
    if found_start and found_end:
        with open(path, "w") as file:
            file.writelines(new_lines)

    print_success(" -> modified")


def generate_cpp_code(settings, model):
    forces_solver_name = solver_name(settings)

    header_file = open(generated_include_file(settings), "w")

    header_file.write(
        "/** This file was autogenerated by the mpc-planner-solver package at "
        + datetime.datetime.now().strftime("%I:%M%p on %B %d, %Y")
        + "*/\n"
    )

    # IMPORTS
    header_file.write("#ifndef __MPC_PLANNER_GENERATED_H__\n" "#define __MPC_PLANNER_GENERATED_H__\n\n" "#include <Solver.h>\n\n")

    header_file.write("namespace MPCPlanner{\n\n")

    N = settings["N"]
    header_file.write(f"double getForcesOutput(const {forces_solver_name}_output& output, const int k, const int var_index){{\n")
    for k in range(settings["N"]):
        header_file.write(f"\t\tif(k == {k})\n")
        if k == 0:
            header_file.write(
                f"\t\t\t{{\n"
                f"\t\t\t\tif(var_index >= {model.nu})"
                f'\t\t\t\t\tLOG_WARN("getForcesOutput for k = 0 returns the initial state.");\n'
            )
        header_file.write(f"\t\t\treturn output.x{add_zero_below_10(k+1, N)}[var_index];\n")
        if k == 0:
            header_file.write("\t\t}\n")

    header_file.write('throw std::runtime_error("Invalid k value for getForcesOutput");\n')
    header_file.write("}\n\n")

    header_file.write(f"void loadForcesWarmstart({forces_solver_name}_params& params, const {forces_solver_name}_output& output){{\n")
    header_file.write(f"\t\tfor (int i = 0; i < {model.nu}; i++){{\n")
    header_file.write(f"\t\t\tparams.z_init_{add_zero_below_10(0, N)}[i] = params.x0[i];\n\t\t}}\n")

    header_file.write(f"\t\tfor (int i = 0; i < {model.get_nvar()}; i++){{\n")
    for k in range(1, N):
        header_file.write(f"\t\t\tparams.z_init_{add_zero_below_10(k, N)}[i] = params.x0[{model.get_nvar()}*{k} + i];\n")
    header_file.write("\t\t}\n\t}")

    header_file.write("}\n#endif")

    print_success(" -> generated")
    return


def generate_rqtreconfigure(settings):
    current_package = get_current_package()
    path = f"{get_package_path(current_package)}/cfg/"
    os.makedirs(path, exist_ok=True)
    path += "settings.cfg"
    print_path("RQT Reconfigure", path, end="", tab=True)
    rqt_file = open(path, "w")

    rqt_file.write("#!/usr/bin/env python\n")
    rqt_file.write(f'PACKAGE = "{current_package}"\n')
    rqt_file.write("from dynamic_reconfigure.parameter_generator_catkin import *\n")
    rqt_file.write("gen = ParameterGenerator()\n\n")

    rqt_file.write('weight_params = gen.add_group("Weights", "Weights")\n')
    rqt_params = settings["params"].rqt_params
    for param in rqt_params:
        rqt_file.write(f'weight_params.add("{param}", double_t, 1, "{param}", 1.0, 0.0, 100.0)\n')
    rqt_file.write(f'exit(gen.generate(PACKAGE, "{current_package}", ""))\n')
    rqt_file.close()
    print_success(" -> generated")

    current_package = get_current_package()
    path = f"{get_package_path(current_package)}/include/{current_package}/"
    os.makedirs(path, exist_ok=True)
    system_name = "".join(current_package.split("_")[2:])
    path += f"{system_name}_reconfigure.h"
    print_path("RQT Reconfigure Header", path, end="", tab=True)
    rqt_header = open(path, "w")

    class_name = "Reconfigure"
    rqt_header.write("#ifndef __GENERATED_RECONFIGURE_H\n")
    rqt_header.write("#define __GENERATED_RECONFIGURE_H\n\n")
    rqt_header.write("#include <ros/ros.h>\n\n")
    rqt_header.write("#include <ros_tools/logging.h>\n")
    rqt_header.write("#include <mpc-planner-util/parameters.h>\n\n")
    rqt_header.write("// Dynamic Reconfigure server\n")
    rqt_header.write("#include <dynamic_reconfigure/server.h>\n")
    rqt_header.write(f"#include <{current_package}/Config.h>\n\n")
    rqt_header.write(f"class {class_name}\n")
    rqt_header.write("{\n")
    rqt_header.write("public:\n")
    rqt_header.write(f"\t{class_name}()\n")
    rqt_header.write("\t{\n")
    rqt_header.write("\t\t// Initialize the dynamic reconfiguration\n")
    rqt_header.write('\t\tLOG_INFO("Setting up dynamic_reconfigure server for the parameters");\n')
    rqt_header.write("\t\t// first_reconfigure_callback_ = true;\n")
    rqt_header.write(f'\t\tros::NodeHandle nh_reconfigure("{current_package}");\n')
    rqt_header.write(
        f"\t\t_reconfigure_server.reset(new dynamic_reconfigure::Server<{current_package}::Config>(_reconfig_mutex, nh_reconfigure));\n"
    )
    rqt_header.write(f"\t\t_reconfigure_server->setCallback(boost::bind(&{class_name}::reconfigureCallback, this, _1, _2));\n")
    rqt_header.write("\t}\n")
    rqt_header.write(f"\tvoid reconfigureCallback({current_package}::Config &config, uint32_t level)\n")
    rqt_header.write("\t{\n")
    rqt_header.write("\t\t(void)level;\n")
    rqt_header.write("\t\tif (_first_reconfigure_callback){\n")
    for idx, param in enumerate(rqt_params):
        rqt_header.write(f'\t\t\tconfig.{param} = CONFIG{settings["params"].rqt_param_config_names[idx](param)}.as<double>();\n')
    rqt_header.write("\t\t\t_first_reconfigure_callback = false;\n")
    rqt_header.write("\t\t}else{\n")
    for idx, param in enumerate(rqt_params):
        rqt_header.write(f'\t\t\tCONFIG{settings["params"].rqt_param_config_names[idx](param)} = config.{param};\n')
    rqt_header.write("\t\t}\n")

    rqt_header.write("\t}\n\n")
    rqt_header.write("private:\n")
    rqt_header.write("\tbool _first_reconfigure_callback{true};\n")
    rqt_header.write("\t// RQT Reconfigure ROS1\n")
    rqt_header.write(f"\tboost::shared_ptr<dynamic_reconfigure::Server<{current_package}::Config>> _reconfigure_server;\n")
    rqt_header.write("\tboost::recursive_mutex _reconfig_mutex;\n")
    rqt_header.write("};\n\n")
    rqt_header.write("#endif // __GENERATED_RECONFIGURE_H\n")
    rqt_header.close()
    print_success(" -> generated")
