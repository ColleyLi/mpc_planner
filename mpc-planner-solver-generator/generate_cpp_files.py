import datetime

from util.code_generation import tabs, open_function, close_function, add_zero_below_10
from util.files import (
    generated_src_file,
    generated_include_file,
    solver_name,
    get_package_path,
    planner_path,
)

from util.logging import print_success, print_path


def generate_module_header(modules):
    path = f"{get_package_path('mpc-planner-modules')}/include/mpc-planner-modules/modules.h"
    print_path("Module Header", path, end="", tab=True)

    module_header = open(path, "w")

    module_header.write("#ifndef __MPC_PLANNER_GENERATED_MODULES_H__\n")
    module_header.write("#define __MPC_PLANNER_GENERATED_MODULES_H__\n\n")
    for module in modules.modules:
        module_header.write(f"#include <mpc-planner-modules/{module.import_name}>\n")
        for source in module.sources:
            module_header.write(f"#include <mpc-planner-modules/{source}>\n")

    module_header.write("\n")

    module_header.write("namespace MPCPlanner\n{\n")
    module_header.write("\tclass Solver;\n")
    module_header.write(
        "\tinline void initializeModules(std::vector<std::shared_ptr<ControllerModule>> &modules, std::shared_ptr<Solver> solver)\n\t{\n"
    )

    for module in modules.modules:
        module_header.write("\t\tmodules.emplace_back(nullptr);\n")
        module_header.write("\t\tmodules.back() = std::make_shared<" + module.module_name + ">(solver);\n")
    module_header.write("\n\t}\n")
    module_header.write("}")

    module_header.write("\n#endif")

    module_header.close()
    print_success(" -> generated")


def generate_module_definitions(modules):
    path = f"{get_package_path('mpc-planner-modules')}/include/mpc-planner-modules/definitions.h"
    print_path("Definition Header", path, end="", tab=True)

    definitions_header = open(path, "w")

    definitions_header.write("#ifndef __MPC_PLANNER_GENERATED_DEFINITIONS_H__\n")
    definitions_header.write("#define __MPC_PLANNER_GENERATED_DEFINITIONS_H__\n\n")

    for module in modules.modules:
        module.add_definitions(definitions_header)
    definitions_header.write("\n")

    definitions_header.write("\n#endif")

    definitions_header.close()
    print_success(" -> generated")


def generate_module_cmake(modules):
    path = f"{get_package_path('mpc-planner-modules')}/modules.cmake"
    print_path("Module CMake", path, end="", tab=True)
    module_cmake = open(path, "w")
    # module_cmake.write("set(MODULE_DEPENDENCIES\n")

    module_cmake.write("set(MODULE_SOURCES\n")
    for module in modules.modules:
        module_cmake.write(f"\tsrc/{module.import_name.split('.')[0]}.cpp\n")
        for source in module.sources:
            module_cmake.write(f"\tsrc/{source.split('.')[0]}.cpp\n")

    module_cmake.write(")\n")
    module_cmake.close()
    print_success(" -> generated")


def generate_cpp_code(settings, model):
    forces_solver_name = solver_name(settings)

    header_file = open(generated_include_file(settings), "w")

    header_file.write(
        "/** This file was autogenerated by the mpc-planner-solver package at "
        + datetime.datetime.now().strftime("%I:%M%p on %B %d, %Y")
        + "*/\n"
    )

    # IMPORTS
    header_file.write("#ifndef __MPC_PLANNER_GENERATED_H__\n" "#define __MPC_PLANNER_GENERATED_H__\n\n" "#include <Solver.h>\n\n")

    header_file.write("namespace MPCPlanner{\n\n")

    N = settings["N"]
    header_file.write(f"double getForcesOutput(const {forces_solver_name}_output& output, const int k, const int var_index){{\n")
    for k in range(settings["N"]):
        header_file.write(f"\t\tif(k == {k})\n")
        if k == 0:
            header_file.write(
                f"\t\t\t{{\n"
                f"\t\t\t\tif(var_index >= {model.nu})"
                f'\t\t\t\t\tLOG_WARN("getForcesOutput for k = 0 returns the initial state.");\n'
            )
        header_file.write(f"\t\t\treturn output.x{add_zero_below_10(k+1, N)}[var_index];\n")
        if k == 0:
            header_file.write("\t\t}\n")

    header_file.write('throw std::runtime_error("Invalid k value for getForcesOutput");\n')
    header_file.write("}\n\n")

    header_file.write(f"void loadForcesWarmstart({forces_solver_name}_params& params, const {forces_solver_name}_output& output){{\n")
    header_file.write(f"\t\tfor (int i = 0; i < {model.nu}; i++){{\n")
    header_file.write(f"\t\t\tparams.z_init_{add_zero_below_10(0, N)}[i] = params.x0[i];\n\t\t}}\n")

    header_file.write(f"\t\tfor (int i = 0; i < {model.get_nvar()}; i++){{\n")
    for k in range(1, N):
        header_file.write(f"\t\t\tparams.z_init_{add_zero_below_10(k, N)}[i] = params.x0[{model.get_nvar()}*{k} + i];\n")
    header_file.write("\t\t}\n\t}")

    header_file.write("}\n#endif")

    print_success(" -> generated")
    return
